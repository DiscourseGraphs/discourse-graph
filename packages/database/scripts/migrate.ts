import { spawnSync } from "node:child_process";
import { writeFileSync, opendirSync } from "node:fs";
import { join, dirname } from "node:path";
import { readSync, openDir } from "dir";
import { getVariant } from "@repo/database/dbDotEnv";

const __dirname = dirname(__filename);
const projectRoot = join(__dirname, "..");

if (process.env.HOME === "/vercel") {
  console.log("Not running in production environment");
  process.exit(0);
}

const includeAll = process.argv[process.argv.length - 1] === "--include-all";
const reapply = process.argv[process.argv.length - 2] === "--reapply";
const reapplyVersion = reapply ? process.argv[process.argv.length - 1]! : "";
if (getVariant() === "none") {
  console.log("Not using the database");
  process.exit(0);
}
if (getVariant() === "production") {
  console.log("Not updating the production database");
  process.exit(1);
}
const startResult = spawnSync("supabase start", {
  cwd: projectRoot,
});
if (startResult.status) {
  process.exit(1);
}
if (reapply) {
  const dir = opendirSync(join(projectRoot, "supabase", "migrations"));
  const files = [];
  while (true) {
    const f = dir.readSync();
    if (f === null) break;
    files.push(f.name.substring(0, 14));
  }
  if (!files.length) {
    console.error("No migration files found");
    process.exit(1);
  }
  files.sort();
  const lastVersion = files[files.length - 1];
  if (reapplyVersion !== lastVersion) {
    console.error(
      `The expected migration version ${reapplyVersion} does not match the latest version ${lastVersion}.`,
    );
    process.exit(1);
  }
  console.log("Reverting migration " + reapplyVersion);
  const result = spawnSync(
    "supabase",
    ["migration", "repair", "--status", "reverted", "--local", reapplyVersion],
    {
      cwd: projectRoot,
    },
  );
  if (result.status) {
    console.error(result.stderr?.toString());
    process.exit(1);
  }
}
let migrationArgs = ["migration", "up", "--local"];
if (includeAll) migrationArgs.push("--include-all");
const migrationResult = spawnSync("supabase", migrationArgs, {
  cwd: projectRoot,
});
const stderr = migrationResult.stderr?.toString() || "";
if (
  !includeAll &&
  migrationResult.status &&
  stderr.includes("with --include-all")
) {
  console.error(stderr);
  console.log("Consider trying again");
  process.exit(1);
}
if (migrationResult.status) {
  console.error(stderr);
  process.exit(migrationResult.status);
}
const migrationLines = stderr
  .split("\n")
  .filter((line) => line.startsWith("Applying migration "));

if (migrationLines.length > 0) {
  console.log(migrationLines.join("\n"));
  console.log("Migrations were applied, regenerating dbTypes");
  const generateResult = spawnSync(
    "supabase",
    ["gen", "types", "typescript", "--local", "--schema", "public"],
    { encoding: "utf8", cwd: projectRoot },
  );
  if (generateResult.status) {
    console.error("Failed to generate types");
    process.exit(1);
  }
  writeFileSync(
    join(projectRoot, "src", "dbTypes.ts"),
    "// Generated by supabase -- do not edit\n" +
      generateResult.stdout.toString(),
  );
} else {
  console.log("No migrations were applied");
}
