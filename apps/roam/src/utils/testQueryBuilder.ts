/**
 * Test harness for Query Builder
 * Generated by opencode with Sonnet 4.5
 *
 * This test runner executes queries against real Roam data without mocking.
 * Test cases are defined as Roam pages under "discourse-graph/tests/queries/"
 *
 * Test Page Structure:
 * - Page Title: discourse-graph/tests/queries/[test-name]
 * - Children:
 *   - description: Brief description of what this test validates
 *   - query: The query block (same structure as regular queries)
 *   - expected: Expected results (optional)
 *     - count: Expected number of results
 *     - contains: UIDs that should be in results
 *     - excludes: UIDs that should NOT be in results
 */

import getPageTitlesStartingWithPrefix from "roamjs-components/queries/getPageTitlesStartingWithPrefix";
import getPageUidByPageTitle from "roamjs-components/queries/getPageUidByPageTitle";
import getBasicTreeByParentUid from "roamjs-components/queries/getBasicTreeByParentUid";
import getSubTree from "roamjs-components/util/getSubTree";
import type { RoamBasicNode } from "roamjs-components/types";
import type { Result } from "roamjs-components/types/query-builder";
import parseQuery from "./parseQuery";
import fireQuery from "./fireQuery";
import { getDatalogQuery } from "./fireQuery";

type ResultDetails = {
  expectedCount?: number;
  actualCount: number;
  query: string;
  missingUids?: string[];
  unexpectedUids?: string[];
};

type PartialResultDetails = Omit<ResultDetails, "query">;

export type TestResult = {
  name: string;
  description: string;
  passed: boolean;
  duration: number;
  error?: string;
  details?: ResultDetails;
};

type TestExpectation = {
  count?: number;
  contains?: string[];
  excludes?: string[];
};

const parseExpectations = (
  expectationsTree: RoamBasicNode[],
): TestExpectation => {
  const countNode = getSubTree({ tree: expectationsTree, key: "count" });
  const containsNode = getSubTree({ tree: expectationsTree, key: "contains" });
  const excludesNode = getSubTree({ tree: expectationsTree, key: "excludes" });

  return {
    count: countNode.children?.[0]?.text
      ? parseInt(countNode.children[0].text, 10)
      : undefined,
    contains: containsNode.children?.map((c: RoamBasicNode) => c.text) || [],
    excludes: excludesNode.children?.map((c: RoamBasicNode) => c.text) || [],
  };
};

const validateResults = (
  results: Result[],
  expectations: TestExpectation,
): { passed: boolean; details: PartialResultDetails } => {
  const details: PartialResultDetails = {
    actualCount: results.length,
  };

  let passed = true;

  // Check count if specified
  if (expectations.count !== undefined) {
    details.expectedCount = expectations.count;
    if (results.length !== expectations.count) {
      passed = false;
    }
  }

  // Check that expected UIDs are present
  if (expectations.contains && expectations.contains.length > 0) {
    const resultUids = new Set(results.map((r) => r.uid));
    const missing = expectations.contains.filter((uid) => !resultUids.has(uid));
    if (missing.length > 0) {
      passed = false;
      details.missingUids = missing;
    }
  }

  // Check that excluded UIDs are NOT present
  if (expectations.excludes && expectations.excludes.length > 0) {
    const resultUids = new Set(results.map((r) => r.uid));
    const unexpected = expectations.excludes.filter((uid) =>
      resultUids.has(uid),
    );
    if (unexpected.length > 0) {
      passed = false;
      details.unexpectedUids = unexpected;
    }
  }

  return { passed, details };
};

export const runSingleTest = async (
  testPageTitle: string,
): Promise<TestResult> => {
  const testName = testPageTitle.replace("discourse-graph/tests/queries/", "");
  const testPageUid = getPageUidByPageTitle(testPageTitle);

  if (!testPageUid) {
    return {
      name: testName,
      description: "",
      passed: false,
      duration: 0,
      error: "Test page not found",
    };
  }

  const testTree = getBasicTreeByParentUid(testPageUid);
  const descriptionNode = getSubTree({ tree: testTree, key: "description" });
  const queryNode = getSubTree({ tree: testTree, key: "{{query block}}" });
  const expectedNode = getSubTree({ tree: testTree, key: "expected" });

  if (!queryNode.uid) {
    return {
      name: testName,
      description: descriptionNode.children?.[0]?.text || "",
      passed: false,
      duration: 0,
      error: "No query block found in test",
    };
  }

  const expectations = expectedNode.uid
    ? parseExpectations(expectedNode.children)
    : {};

  try {
    const startTime = performance.now();

    // Parse and execute query
    const queryArgs = parseQuery(queryNode.uid);
    const { query } = getDatalogQuery(queryArgs);
    const results = await fireQuery(queryArgs);

    const endTime = performance.now();
    const duration = endTime - startTime;

    // Validate results
    const { passed, details } = validateResults(results, expectations);

    return {
      name: testName,
      description: descriptionNode.children?.[0]?.text || "",
      passed,
      duration,
      details: {
        ...details,
        query,
      },
    };
  } catch (error) {
    return {
      name: testName,
      description: descriptionNode.children?.[0]?.text || "",
      passed: false,
      duration: 0,
      error: (error as Error).message,
    };
  }
};

export const runAllTests = async (): Promise<TestResult[]> => {
  const testPages = getPageTitlesStartingWithPrefix(
    "discourse-graph/tests/queries/",
  );

  const results: TestResult[] = [];

  for (const testPage of testPages) {
    const result = await runSingleTest(testPage);
    results.push(result);
  }

  return results;
};

export const formatTestResults = (results: TestResult[]): string => {
  const totalTests = results.length;
  const passedTests = results.filter((r) => r.passed).length;
  const failedTests = totalTests - passedTests;

  const lines: string[] = [];
  lines.push(`\n${"=".repeat(60)}`);
  lines.push(`Query Builder Test Results`);
  lines.push(`${"=".repeat(60)}`);
  lines.push(
    `Total: ${totalTests} | Passed: ${passedTests} | Failed: ${failedTests}`,
  );
  lines.push(`${"=".repeat(60)}\n`);

  results.forEach((result) => {
    const status = result.passed ? "✓ PASS" : "✗ FAIL";
    const statusColor = result.passed ? "\x1b[32m" : "\x1b[31m";
    const resetColor = "\x1b[0m";

    lines.push(
      `${statusColor}${status}${resetColor} ${result.name} (${result.duration.toFixed(2)}ms)`,
    );

    if (result.description) {
      lines.push(`  Description: ${result.description}`);
    }

    if (!result.passed) {
      if (result.error) {
        lines.push(`  Error: ${result.error}`);
      }

      if (result.details) {
        if (result.details.expectedCount !== undefined) {
          lines.push(
            `  Expected ${result.details.expectedCount} results, got ${result.details.actualCount}`,
          );
        }

        if (
          result.details.missingUids &&
          result.details.missingUids.length > 0
        ) {
          lines.push(
            `  Missing UIDs: ${result.details.missingUids.join(", ")}`,
          );
        }

        if (
          result.details.unexpectedUids &&
          result.details.unexpectedUids.length > 0
        ) {
          lines.push(
            `  Unexpected UIDs: ${result.details.unexpectedUids.join(", ")}`,
          );
        }
      }
    }

    lines.push("");
  });

  return lines.join("\n");
};

export const formatBenchmarkResults = (results: TestResult[]): string => {
  const lines: string[] = [];
  lines.push(`\n${"=".repeat(60)}`);
  lines.push(`Query Builder Benchmark Results`);
  lines.push(`${"=".repeat(60)}\n`);

  // Sort by duration (slowest first)
  const sortedResults = [...results].sort((a, b) => b.duration - a.duration);

  const maxNameLength = Math.max(
    ...sortedResults.map((r) => r.name.length),
    20,
  );

  lines.push(`${"Test Name".padEnd(maxNameLength)} | Duration (ms) | Status`);
  lines.push(`${"-".repeat(maxNameLength)}-|--------------:|-------`);

  sortedResults.forEach((result) => {
    const status = result.passed ? "PASS" : "FAIL";
    lines.push(
      `${result.name.padEnd(maxNameLength)} | ${result.duration.toFixed(2).padStart(12)} | ${status}`,
    );
  });

  // Summary statistics
  const totalDuration = results.reduce((sum, r) => sum + r.duration, 0);
  const avgDuration = totalDuration / results.length;
  const minDuration = Math.min(...results.map((r) => r.duration));
  const maxDuration = Math.max(...results.map((r) => r.duration));

  lines.push(`\n${"=".repeat(60)}`);
  lines.push(`Summary Statistics:`);
  lines.push(`  Total Time: ${totalDuration.toFixed(2)}ms`);
  lines.push(`  Average: ${avgDuration.toFixed(2)}ms`);
  lines.push(`  Min: ${minDuration.toFixed(2)}ms`);
  lines.push(`  Max: ${maxDuration.toFixed(2)}ms`);
  lines.push(`${"=".repeat(60)}\n`);

  return lines.join("\n");
};

/**
 * Run tests and log results to console
 */
export const runTestsWithConsoleOutput = async () => {
  console.log("Starting Query Builder tests...");

  const results = await runAllTests();

  console.log(formatTestResults(results));
  console.log(formatBenchmarkResults(results));

  return results;
};

export default {
  runSingleTest,
  runAllTests,
  formatTestResults,
  formatBenchmarkResults,
  runTestsWithConsoleOutput,
};
